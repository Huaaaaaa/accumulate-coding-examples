访问者模式：Visitor Design Pattern
引入问题：存在某个对象有多种不同的元素，且每种元素也存在多种不同的访问者和处理方式，例如电影中有不同的角色，每个人对每种角色的评价都都不相同

一、模式定义
将作用于某种数据结构中的各元素的操作分离出来，封装成单独的类，使其在不改变数据结构的前提下，可以添加对这些元素的新操作，为数据结构中的每个元素提供多种访问
方式。它将数据结构与数据操作分离，该模式的关键在于数据结构中的元素个数是固定的，且对它们的操作可以进行扩展。总之就是为了便于给一组元素扩展新的操作功能，毕竟是
行为型模式，就是将行为（操作）抽取出来并封装成对象，便于扩展！！

二、优缺点
1、优点
●扩展性好：能够在不修改对象结构中元素的情况下，为对象结构中的元素添加新的功能
●复用性好：可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度
●灵活性好：将数据结构与作用于数据结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构
●符合单一职责原则：将行为封装成对象构成访问者，使得每个访问者的功能都比较单一

2、缺点
●如果增加了新元素，就要在每个访问者类中增加相应的具体操作，违背了开闭原则
●破坏封装：具体元素对访问者公布了细节（依赖），破坏了对象的封装性
●违背了依赖倒置原则：访问者模式依赖了具体的类，而不是抽象类（双委派决定）

三、角色分析
1、抽象访问者（Visitor）:定义一个访问具体原色的接口，为每个具体元素类对应一个访问操作visit(),该操作中的参数类型标识了被访问
的具体元素
2、具体访问者（ConcreteVisitor）：实现抽象访问者中声明的各个访问操作，确定一个访问者访问一个元素时该做什么
3、抽象元素（Element）：声明一个包含接受操作accept()的接口，被接受的访问者对象作为accept的方法参数
4、具体元素（ConcreteElement）：实现抽象元素声明的accept()接口，其方法体通常都是visitor.visit(this)，另外具体元素中可能还包含本身业务
逻辑的相关操作
5、对象结构（Object Structure）：一个包含元素的容器，提供让访问者对象遍历容器中所有元素的方法，通常由List、Set、Map等聚合类实现

四、实例分析（极客时间设计模式之美）
假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，
把这些资源文件中的文本内容抽取出来放到 txt 文件中。
实现方式一：
ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。
PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。
在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。

存在的问题：
当对资源的操作不止是抽取内容，还要增加别的比如压缩、解压等功能时，就要在每个类中都实现这个新功能，违背了开闭原则；

实现方式二：
将操作与数据结构解耦，将其设计成独立的类，在该类中针对每种Resource实现其extract2txt()方法（重载）
存在的问题：
在集合中，Resource是抽象类，但是传入extract2txt()的参数必须是具体的类，导致编译不通过，因为：
多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。
而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。


实现方式三：
针对第二种方式中存在的问题，可以选择访问者模式，通过双委派解决
